# Проект: телекоммуникации

## Описание проекта

Оператор связи «ТелеДом» хочет бороться с оттоком клиентов. Для этого его сотрудники начнут предлагать промокоды и специальные условия всем, кто планирует отказаться от услуг связи. Чтобы заранее находить таких пользователей, «ТелеДому» нужна модель, которая будет предсказывать, разорвёт ли абонент договор. Команда оператора собрала персональные данные о некоторых клиентах, информацию об их тарифах и услугах. Задача — обучить на этих данных модель для прогноза оттока клиентов.  


## Навыки и инструменты

- **python**
- **pandas**
- **numpy**
- **phik**
- sklearn.model_selection.**GridSearchCV**
- sklearn.linear_model.**LogisticRegression**
- sklearn.model_selection.**cross_val_score**
- **catboost**
- **shap**
- **matplotlib**
- **seaborn**

## 

## Общий вывод

Изучили и объединили данные оператор связи «ТелеДом». Данные состояли из 4 файлов с информацией о договоре, о персональных данных клиента, об интернет-услугах, об услугах телефонии.     
Обнаружили в столбце "TotalCharges" пустые строки и удалили этих абонентов, так как они только что оформили договор.
Преобразовали типы данных в столбцах `TotalCharges` и `BeginDate`.     
В данных нет дубликатов и аномалий.     
Количество ушедших клиентов действительно растёт каждый год.    
Исследовав данные видим, что файлы разных размеров. В них разное количество уникальных `customerID`. Поэтому при объединении в некоторых столбцах у нас появятся пропуски.    
Многие признаки оказались бинарными - всего два варианта (да или нет)     
Тип объединения выбрали merge left. Так как необходимо сохранить большую часть <u>customerID</u>, кроме тех, которые были удалены из-за пропусков в <u>TotalCharges</u>     
В объединённых данных появились пропуски. Пропуски необходимо как-то заполнить. Пропуски в данных столбцах означают, что у абонента не подключены данные услуги. Но мы не можем заполнить их просто как "No", так как нужно различать пользователей, у которых не подключена какая-то услуга, и у которых в принципе не подключён интернет.      
Из данных создали целевой признак `leave`, который говорит ушёл клиент или нет.     
Создали новый признак `contract_duration` - длительность контракта в днях.     
С помощью библиотеки phik вычислили корреляцию признаков. Перед этим удалили "customerID" из-за неинформативности и "BeginDate" с "EndDate" из-за утечки данных.     
По матрице корреляции видно, что признаки очень сильно коррелируют между собой начиная с `InternetService` и до `StreamingMovies` включительно.     
Так что оставим только один признак. Это будет `OnlineBackup`, так как он большего всего коррелирует с целевым признаком.
Также `MonthlyCharges` сильно коррелирует с `MultipleLines`, и `TotalCharges` с `contract_duration`.
И `Type` сильно коррелирует c `contract_duration`.     
Признак `gender` практически не коррелирует с целевым, так что его тоже уберём.    
Рассмотрели каждый оставшийся признак в разрезе ушел/остался клиент.     
Достаточно сильно отличалось распределение для 'PaymentMethod', 'Partner', 'OnlineBackup', 'MultipleLines' и особенно сильно 'contract_duration'.     
Разделили данные на признаки и целевой признак. А после на обучающую и тестовую выборку.      
Создали копию X_train и X_test для модели CatBoostClassifier, так как для неё не нужно кодировать категориальные признаки.
В качестве моделей машинного обучения выбрали `LogisticRegression` и `CatBoostClassifier`.      
Данные для `LogisticRegression` закодировали и масштабировали.      
Обучили обе модели и посчитали AUC-ROC на кросс-валидации.      
Для CatBoostClassifier перебирали несколько признаков и для лучшей модели получили ROC_AUC на кросс-валидации ~0.919      
Построили ROC кривую, площадь близка к площади квадрата.     
Дополнительно посчитали Accuracy и построили матрицу ошибок      
Достаточно много False Positive. Модель правильно определила почти всех, кто ушёл. Но при этом добавила к ним ещё 96 абонентов, которые не планировали уходить.      
Это не очень хорошо, так как сотрудники начнут предлагать промокоды и специальные условия тем клиентам, которые не собираются уходить. Но в данном случае значение *Recall* всё-таки важнее, чем *Precision*. 
